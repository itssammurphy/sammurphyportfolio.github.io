<!DOCTYPE html>
<html lang="en">

  <head>

    <title>Sam's ePortfolio</title>
    <link rel="stylesheet" href="assets/css/style.css" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8" />

  </head>
  <body>
    <header>
        <h2><a href="index.html">Sam Murphy</a></h2>
        <nav>
          <li><a href="index.html">Home</a></li>
          <li><a href="about-me.html">About Me</a></li>
          <li><a href="#">Projects</a></li>
          <li><a href="contact.html">Contact</a></li>
        </nav>
    </header>
    <section class="banner-area">
      <div class="banner-img"></div>
      <h1>My Projects</h1>
    </section>
    <section class="main-content">

      <h1 class='type-line anim-typewriter'>GitHub Repos</h1> <!-- WIDTH: 0.62em per character -->
      <div class="justified-content">
        <p>To look at my growing collection of coding projects through my GitHub repositories, click below:</p>
        <a style="margin-bottom: 20px;" href="github.html"><img style="width: 50px; height: 50px;" src="assets/img/github.png" /></a>
        <p>Alternatively, if you want to explore my projects in a bit more depth you can scroll down on this page
        to view a synopsis of each of my more major projects and others I found particularly cool or useful.</p>
      </div>
    </section>
    <section class="main-content">
      <h1 style="text-decoration: underline;">A* Pathfinding</h1>
      <div class="left-content">
        <p><b>In this project, I learned to create a Python implementation of the A* Pathfinding algorithm.</b><br><br>
        Asides from being among possibly the most commonly cited programming examples ever, A* is a highly efficient pathfinding algorithm which many
        programmers turn to due to it's incredible efficiency (caused by its <i>best-first</i> approach rather than brute force).<br><br>
        Other pathfinding algorithms do exist - notably Dijkstra's Shortest Path, but I chose to work with A* for this project as it is
        a more optimal search algorithm. A* is simply an expansion on Dijkstra's algorithm which adds a heuristic function to help navigate
        the search towards the goal more efficiently, rather than purely based on the weights of the paths.<br><br>
        On the right, you can see a screenshot of what my visualisation looks like on a solved puzzle. I used various colours to depict
        the functions each cell was taking. For example, the red squares are squares that are <i>no longer being considered by the algorithm</i>,
        green cells are cells that are in the <i>open set</i>, awaiting consideration. As a path has been found, the blue line indicates the shortest
        path from A -> B as found by the algorithm. The start and end points are hidden but are coloured orange and purple respectively. All of the weights
        of edges in the network are 1, as all cells are of equal size.<br><br>
        This project is only dependent on PyGame, and a Python 3.8+ install.<br><br>
        To take a look at the code for yourself, go check out the <a href="https://github.com/sammurphyportfolio/astar-python-implementation">GitHub Repository</a> for this project.</p>
        <br><img src="assets/img/astar-example.jpg" />
      </div>

      <h1 style="text-decoration: underline;">C++ Sudoku Solver</h1>
      <div class="left-content">
        <p><b>In this project I used a recursive algorithm in C++ to solve sudoku puzzles.</b><br><br>
        Sudokus are an all-time classic puzzle. They were invented in Japan in the 80's and have remained
        resistant to the constantly changing media to the point where they are still finding a way into our daily newspapers.<br><br>
        Sudokus are quite complex puzzles, with deceptively simple rules which can often mess up people's solutions
        without them realising. This property, however, makes them perfect for a programming example project.<br><br>
        Using a recursive back-tracking algorithm which I coded in C++, I was able to make an effective Sudoku solver
        that runs from my command line. The algorithm works by going through each cell sequentially and attempting each
        possibiity, this is known as a <i>depth-first</i> search. For other applications, these depth-first, brute-force
        algorithms are not as appealing due to their inefficiency, but due to the fact that Sudokus are algorithmically
        less complicated to develop for than most applications, this approach is most often used. The algorithm is
        also beautifully simple, and guarantees a solution on any valid sudoku.<br><br>
        It works by placing the number 1 in the first empty cell, and checking if that cell is allowed to hold a 1, if it
        is it moves on to the next cell, sets it to 1 and checks for violations. If it is not allowed to hold a 1, it increments
        to 2, and so on. If a cell is found where none of the numbers 0->9 are allowed, the algorithm goes back a cell and
        increments its value by one. This continues until the Sudoku is solved.<br><br>
        To take a look at the code for yourself, go check out the <a href="https://github.com/sammurphyportfolio/sudoku-solver">GitHub Repository</a> for this project.</p>
        <br><img src="assets/img/sudoku-example.jpg" />
      </div>
    </section>
    <section class="bottom-bar">
      <div class="bottom-bar-content">
        <h1>SAM MURPHY</h1>
        <!-- <span class="location"><h2><img src="assets/img/pin.png" /> Melbourne, Australia</h2></span> -->
        <div class="bottom-socials">
          <a href="twitter.html"><img src="assets/img/twitter.png" /></a>
          <a href="twitter.html"><img src="assets/img/discord.png" /></a>
          <a href="twitter.html"><img style="width: 65px; height: 63px;" src="assets/img/youtube.png" /></a>
        </div>
      </div>
    </section>
  </body>

</html>
